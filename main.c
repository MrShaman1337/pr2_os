#include <windows.h>
#include <stdio.h>

#define THREAD_COUNT 5

DWORD WINAPI ThreadFunction(LPVOID lpParam); // Объявляем функцию потока, которая будет выполняться в каждом созданном потоке. Если подробнее,то DWORD - это возвращаемое 32-битное целое число
// WINAPI - это мы указываем стандарт, в нашем случае WINAPI, ThreadFunction - это название нашей функции, а LPVOID lpParam - это аргумент, который принимает функция. LPVOID - указатель на произвольные данные.

int threadDurations[THREAD_COUNT] = {0}; // Глобальная переменная, которая хранит кол. потоков.

int main() {
    // ниже я объявляю массивы для работы с потоками.
    HANDLE threads[THREAD_COUNT]; // HANDLE - тип данных, который используют для работы с дескрипторами. т.е threads будет хранить дескриптор потока.
    DWORD threadIds[THREAD_COUNT]; // DWORD - это тоже тип данных, но он хранит 32-битное целое беззнаковое число. т.е threadsids будет хранить идентификаторы потоков.

    while (1) {
        // Выполняю запрос на время длительности потока.
        printf("Введите длительность работы каждого из %d потоков (в секундах):\n", THREAD_COUNT);
        for (int i = 0; i < THREAD_COUNT; i++) {
            printf("Поток %d: ", i + 1);
            scanf("%d", &threadDurations[i]);
        }

        // Тут создаю функцию
        for (int i = 0; i < THREAD_COUNT; i++) {
            printf("%d-й поток начал работу\n", i + 1);
            threads[i] = CreateThread(
                NULL,               // Атрибуты безопасности.
                0,                  // Размер стека.
                ThreadFunction,     // Функция потока.
                (LPVOID)(i + 1),    // Параметр потока.
                0,                  // Флаг создания, в нашем случае нужно его создать немедленно, для этого ставим 0.
                &threadIds[i]       // Идентификатор потока
            );

            if (threads[i] == NULL) {
                printf("Ошибка при создании потока %d\n", i + 1);  // если не удается создать, то указываем что ошибка при его создании и возвращаемся на создание потока.
                return 1;
            }
        }

        // Ниже использую функцию для того, что бы синхронизировать работу потоков. THREAD_COUNT - это количество потоков, которые нужно синхронизировать. Далее идет переменная с дескрипторами потоков.
        WaitForMultipleObjects(THREAD_COUNT, threads, TRUE, INFINITE); // 3 флаг отвечает за режим ожидания. В нашем случае мы ставим TRUE и ждём завершения всех потоков.
        // 4 флаг отвечает за время ожидания окончания работы потоков. В нашем случае мы ждем до последнего работающего потока.
        // После того как я воспользовался дескрипторами, закрываю их.
        for (int i = 0; i < THREAD_COUNT; i++) {
            CloseHandle(threads[i]);
        }

        // Выполняю запрос для того, что бы закончить или начать занового.
        printf("\nНажмите x, чтобы выйти, нажмите r, чтобы перезапустить: ");
        char choice; // Создаю переменную выбора. В зависимости ответа, либо завершаю программу, либо начинаю занового
        scanf(" %c", &choice);
        if (choice == 'x' || choice == 'X') {
            break;
        }
    }

    return 0;
}
// В заданную ранее функцию потока, добавляю функцию имитации выполнения задачи через Sleep и вывожу что n-ый поток выполнил задачу.
DWORD WINAPI ThreadFunction(LPVOID lpParam) {
    int threadNumber = (int)lpParam;

    // Проводим имитацию выполнения задачи.
    Sleep(threadDurations[threadNumber - 1] * 1000);

    printf("%d-й поток выполнил задачу\n", threadNumber);
    return 0;
}
